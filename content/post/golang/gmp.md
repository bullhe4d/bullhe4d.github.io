---
title: "什么是GMP？"
tags : [ "Golang", "面试" ]
categories : [ "Golang" ]
date: 2022-04-02T09:56:44+08:00
typora-root-url: ../../../static
---

# GMP 

![image-20220402155754224](/images/image-20220402155754224.png)

## 基本含义

G对应一个goroutine

M 对应CPU的物理线程，由内核态管理

P一般和M一一对应，P里面存储当前go routine的上下文环境

P的个数是通过runtime.GOMAXPROCS设定(最大256),Go1.5版本之后默认为物理线程数。在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。

一个线程执行一个P

M共经历三个过程：先从本地队列找，定期会从全局队列找，最后实在没办法，就去别的 P 偷。如下图所示：



## 设计策略

### 复用线程

#### workstealing机制

如果M2线程本地协程队列空了，去M1偷一个过来，然后去全局队列拿，如果都没了，就睡眠或者销毁

#### hand off机制

如果M1线程的某个Goroutine G1阻塞了（比如read文件），内核态启动一个新的M2，把M1剩下的G，G2,G3放到这个新的M线程里，

G1如果在阻塞，M1就睡眠，G1执行完之后，去到别M下，M1自己销毁。

### 利用并行

设置GOMAXPROCS 

### 抢占策略

一个G和一个CPU最多的链接时间10MS，别的G会去占用

#### 全局队列

先从别的P偷，别的P没了再去全局队列偷，偷之前先上锁，偷完解锁。

## 调度流程

1.go func创建 一个g

2.加入本地队列M1，如果满了，放到全局里

3.M会从P的队列里拿一个G来之行，如果一个P里面空了，就去别的M P偷一个，如果别的没有，去拿全局。

4.M调度G是一个循环过程，直到把G执行完

5.如果阻塞了执行 handoff机制

如果本地G队列满了，新加一个G，二分法队列，将前面的G和新加的G打散放入全局

## 自旋队列

省去上下文的开销
