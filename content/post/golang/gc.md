---
title: "什么是GMP？"
tags : [ "Golang", "面试" ]
categories : [ "Golang" ]
date: 2022-04-02T09:56:44+08:00
---

# Golang的GC垃圾回收机制

堆和栈

栈是静态的，程序一启动就确定了，堆是动态的。运行的时候会变化

栈stack(快，省心，但不灵活)
在编译时就知道其内容/大小的数据，这部分数据直接被编译在了的可执行文件 中。
由CP U管理。每声明一个新变量，它就会被推入栈，当作用域函数/程序退出时
被释放。
栈会先进后出的顺序来存储（堆放盘子），向栈上推入的数据位置永远处于栈的 顶端，无需找新的数据存储位置，可以高效、快速的读写。
缺点1：无法存放编译时不知道大小的数据。

3。2堆heap(灵活，但没栈省心，没栈快)
由程序管理（(GC/程序员/计数器…)。
编译无法确定大小的数据，将存储在堆中，比如用户输入的文字。
程序根据需要请求特定大小的空间，操作系统找一块足够大且可用空间，把这 片空间的地址返回给程序。
缺点1：需要花时间来记录协调分配。 缺点2：需要跳转，跳转次数越多越慢。 缺点3：数据排布稀疏。

## 标记清除法

程序去扫描所有的对象，查找到所有可达的对象，然后做标记。 然后stw（stop the word，暂停程序），然后sweep掉所有的对象，

###  缺点：

STW 会导致程序卡顿

需要扫描整个heap（堆栈）

清楚的时候会产生碎片

## 三色标记

### 白灰黑三种颜色标记表

第一步：程序创建的时候 所有的对象都是白色

第二步：GC开始的时候 根结点遍历所有的对象， 查找到的对象列为灰色，

第三步：遍历灰色的集合，将灰色对象引用的白色改成灰色，将自己改成黑色

第四步：重复第三步，直到没有灰色对象。

第五步：回收所有的白色

### 如果不被STW 保护

条件1：一个白色对象被黑色对象引用 (白色被挂在黑色下)
条件2：灰色对象与它之间的可达关系的白色对象遭到破坏 (灰色同时丢了该白色)

### 强三色不变式

破坏条件一，黑色不允许运用白色

### 弱三色不变式

破坏条件二，黑色可以引用白色，但是这个白色的上游链路必须被灰色引用。

### 屏障机制

#### 插入屏障

#### 不在栈上使用

具体操作：在A对象引用B对象的时候，B对象被标记为灰色。（将B挂在A下游，B必须被标记为灰色）
满足：强三色不变式。（不存在黑色对象引用白色对象的情况了，因为白色会强制变成灰色）

在准备回收白色前，重新遍历扫描一次栈空间。
此时加STW暂停保护栈，防止外界干扰（有新的白色被黑色添加）

#### 不足

结束时需要STW来重新扫描栈，大约需要10~100ms

#### 删除屏障

`具体操作`: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。

`满足`: **弱三色不变式**. (保护灰色对象到白色对象的路径不会断)

#### 混合写屏障

1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2、GC期间，任何在栈上创建的新对象，均为黑色。

3、被删除的对象标记为灰色。

4、被添加的对象标记为灰色。

`满足`: 变形的**弱三色不变式**.

