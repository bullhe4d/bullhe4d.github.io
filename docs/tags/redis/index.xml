<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redis on Bullhead‘s blog</title>
    <link>https://blog.diudiu.love/tags/redis/</link>
    <description>Recent content in Redis on Bullhead‘s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 02 Apr 2022 09:59:14 +0800</lastBuildDate><atom:link href="https://blog.diudiu.love/tags/redis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如果在生产环境中有千万级的key，如果想模糊查询应该用什么命令？</title>
      <link>https://blog.diudiu.love/post/redis/ms1/</link>
      <pubDate>Sat, 02 Apr 2022 09:59:14 +0800</pubDate>
      
      <guid>https://blog.diudiu.love/post/redis/ms1/</guid>
      <description>当时想当然的就回答用keys *结果踩了大坑，keys算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写Redis的其它的指令都会被延后甚至会超时报错.
应该使用Scan
scan特点：
1、复杂度和keys命令一样，也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程
2、提供limit参数，可以控制每次返回结果的最大条数，这里是最大条数，而不是等于limit的条数，因为是匹配查询，是在limit的范围内匹配查询
3、返回的结果可能会有重复
4、遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;
5、单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;</description>
    </item>
    
    <item>
      <title>什么是GMP？</title>
      <link>https://blog.diudiu.love/post/golang/gmp/</link>
      <pubDate>Sat, 02 Apr 2022 09:56:44 +0800</pubDate>
      
      <guid>https://blog.diudiu.love/post/golang/gmp/</guid>
      <description>GMP 基本含义 G对应一个goroutine
M 对应CPU的物理线程，由内核态管理
P一般和M一一对应，P里面存储当前go routine的上下文环境
P的个数是通过runtime.GOMAXPROCS设定(最大256),Go1.5版本之后默认为物理线程数。在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。
一个线程执行一个P
M共经历三个过程：先从本地队列找，定期会从全局队列找，最后实在没办法，就去别的 P 偷。如下图所示：
设计策略 复用线程 workstealing机制 如果M2线程本地协程队列空了，去M1偷一个过来，然后去全局队列拿，如果都没了，就睡眠或者销毁
hand off机制 如果M1线程的某个Goroutine G1阻塞了（比如read文件），内核态启动一个新的M2，把M1剩下的G，G2,G3放到这个新的M线程里，
G1如果在阻塞，M1就睡眠，G1执行完之后，去到别M下，M1自己销毁。
利用并行 设置GOMAXPROCS
抢占策略 一个G和一个CPU最多的链接时间10MS，别的G会去占用
全局队列 先从别的P偷，别的P没了再去全局队列偷，偷之前先上锁，偷完解锁。
调度流程 1.go func创建 一个g
2.加入本地队列M1，如果满了，放到全局里
3.M会从P的队列里拿一个G来之行，如果一个P里面空了，就去别的M P偷一个，如果别的没有，去拿全局。
4.M调度G是一个循环过程，直到把G执行完
5.如果阻塞了执行 handoff机制
如果本地G队列满了，新加一个G，二分法队列，将前面的G和新加的G打散放入全局
自旋队列 省去上下文的开销</description>
    </item>
    
  </channel>
</rss>
